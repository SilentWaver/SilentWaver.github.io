{"meta":{"title":"SilentWaverの博客","subtitle":"","description":"","author":"SilentWaver","url":"https://silentwaver.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"网络协议分析设计 实验","date":"2022-06-25T14:20:46.000Z","updated":"2022-06-25T14:20:46.000Z","comments":true,"path":"2022/06/25/网络协议分析设计 实验/","permalink":"https://silentwaver.github.io/2022/06/25/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1%20%E5%AE%9E%E9%AA%8C/","excerpt":"网络协议分析设计 实验记一下西电网信院2020年网络协议分析设计试验 promela语言建议看书，看基本语法，然后搜两个实例看看，就会了 但这傻逼语言也没几个人用。 jq，wdqr！","text":"网络协议分析设计 实验记一下西电网信院2020年网络协议分析设计试验 promela语言建议看书，看基本语法，然后搜两个实例看看，就会了 但这傻逼语言也没几个人用。 jq，wdqr！ 实验1 数据链路层协议的形式化描述与验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define MAXSEQ 6mtype=&#123;Msg,Ack,Nak,Err,Miss&#125;;chan SenderToReceiver=[1]of&#123;mtype,byte,byte&#125;;chan ReceiverToSender=[1]of&#123;mtype,byte,byte&#125;;proctype SENDER(chan InCh,OutCh)&#123; byte SendData; byte SendSeq; byte ReceivedSeq SendData=0; SendData=0; do ::skipagain: if ::OutCh!Msg(SendData,SendSeq) ::OutCh!Err(0,0) ::OutCh!Miss(0,0) fi; if ::timeout -&gt; goto again ::InCh?Miss(0,0)-&gt; goto again ::InCh?Err(0,0)-&gt; goto again ::InCh?Nak(ReceivedSeq,0)-&gt;end1: goto again ::InCh?Ack(ReceivedSeq,0)-&gt; if ::(ReceivedSeq== SendSeq)-&gt; SendSeq = (SendSeq+1)%MAXSEQ; SendData = (SendData+1)%MAXSEQ; ::(ReceivedSeq!=SendSeq)-&gt; end2: goto again fi; fi; od; &#125; proctype RECEIVER(chan InCh,OutCh)&#123; byte ReceivedData; byte ReceivedSeq; byte ExpectedData=0; byte ExpectedSeq; do ::InCh?Msg(ReceivedData,ReceivedSeq)-&gt; if ::(ReceivedSeq==ExpectedSeq)-&gt; progress: ExpectedSeq=1+ExpectedSeq; ExpectedData=(ExpectedData+1)%MAXSEQ; if ::OutCh!Miss(0,0) ExpectedSeq=ExpectedSeq-1; ExpectedData=(ExpectedData-1)%MAXSEQ; ::OutCh!Ack(ReceivedSeq,0) ::OutCh!Err(0,0) ExpectedSeq=ExpectedSeq-1; ExpectedData=(ExpectedData-1)%MAXSEQ; fi; ::(ReceivedSeq!=ExpectedSeq) if ::OutCh!Nak(ReceivedSeq,0) ::OutCh!Err(0,0) ::OutCh!Miss(0,0) fi; fi; ::InCh?Err(0,0) if ::OutCh!Nak(ReceivedSeq,0) ::OutCh!Err(0,0) ::OutCh!Miss(0,0) fi; ::InCh?Miss(0,0)-&gt;skip; od; &#125; init&#123; atomic&#123; run SENDER(ReceiverToSender,SenderToReceiver); run RECEIVER(SenderToReceiver,ReceiverToSender); &#125; &#125; 实验2 AB协议的形式化描述与验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116mtype = &#123;Err,a,b&#125;;chan SenderToReceiver = [1] of &#123;mtype,byte&#125;;chan ReceiverToSender = [1] of &#123;mtype,byte&#125;;proctype A(chan InCh, OutCh)&#123;S5: if ::OutCh!a(0) ::OutCh!Err(0) ::OutCh!a(0) ::OutCh!a(0) ::OutCh!a(0) fi; goto S4;S4: if ::InCh?Err(0)-&gt;goto S5 ::InCh?b(1)-&gt; goto S1 ::InCh?b(0)-&gt; goto S1 fi;S3: if ::OutCh!Err(0) ::OutCh!a(1) ::OutCh!a(1) ::OutCh!a(1) ::OutCh!a(1) fi; goto S2;S2: if ::InCh?Err(0)-&gt;goto S5 ::InCh?b(1)-&gt;goto S1 ::InCh?b(0)-&gt;goto S3 fi;S1: if ::OutCh!a(1) ::OutCh!Err(0) ::OutCh!a(1) ::OutCh!a(1) ::OutCh!a(1) fi; goto S2 &#125;proctype B(chan InCh, OutCh)&#123; goto S2;S1: if ::OutCh!Err(0) ::OutCh!b(1) ::OutCh!b(1) ::OutCh!b(1) ::OutCh!b(1) fi; goto S2;S2: if ::InCh?Err(0)-&gt;goto S5 ::InCh?a(0)-&gt;goto S3 ::InCh?a(1)-&gt;goto S1 fi;S3: if ::OutCh!Err(0) ::OutCh!b(1) ::OutCh!b(1) ::OutCh!b(1) ::OutCh!b(1) fi; goto S2;S4: if ::InCh?Err(0)-&gt;goto S5 ::InCh?a(0)-&gt;goto S1 ::InCh?a(1)-&gt;goto S1 fi;S5: if ::OutCh?Err(0) ::OutCh!b(0) ::OutCh!b(0) ::OutCh!b(0) ::OutCh!b(0) fi; goto S4&#125;init&#123; atomic&#123; run A(ReceiverToSender,SenderToReceiver); run B(SenderToReceiver, ReceiverToSender); &#125;&#125; 实验3 GBN协议的形式化描述与验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#define MAX 25 //定义发送报文计数的最大值chan s_r=[10] of &#123;mtype,byte,byte&#125;;chan r_s=[10] of &#123;mtype,byte,byte&#125;;mtype=&#123;mesg, ack, err&#125;;proctype udt_sender() //发送端进程&#123; byte s,r,swl;/*swl：first identify s:next trans r：ackNO*/ swl = 0; do ::swl = swl; progress: s = swl; progress1: /*随机发送多个分组*/ if ::s_r!mesg(0,s)-&gt; (swl&lt;=s)-&gt; s = (s+1)%MAX; if ::goto progress1; ::skip fi; ::s_r!err(s,0) -&gt; (swl&lt;=s)-&gt; s = (s+1)%MAX; if ::goto progress1; ::skip fi; ::skip -&gt; //丢失 (swl&lt;=s)-&gt;s = (s+1)%MAX; if ::goto progress1; ::skip fi; fi; if ::timeout -&gt;goto progress/*超时重发*/ ::r_s?err(0,r) -&gt;skip /*错误丢弃*/ ::r_s?ack(r,0) -&gt; if ::(r&lt;swl) -&gt; skip ::(r&gt;s) -&gt;skip ::(swl&lt;=r&lt;=s) -&gt; swl = r; goto progress; fi; fi; od&#125;proctype udt_receiver() //接收端进程&#123; byte t,es;/*t：接收数据，es：预期接收数据*/ es = 0; do ::s_r?mesg(0,t) -&gt; if ::(t==es)-&gt; progress2:es = (es + 1)%MAX; if ::r_s!ack(es,0) ::r_s!err(0,es) ::skip fi ::(t!=es)-&gt; if ::r_s!ack(es,0) ::r_s!err(0,es) ::skip fi fi ::s_r?err(t,0)-&gt; if ::r_s!ack(es,0) ::r_s!err(0,es) ::skip fi od&#125;init&#123; run udt_sender(); run udt_receiver();&#125;","categories":[],"tags":[]},{"title":"","slug":"对JS闭包的理解","date":"2022-06-25T14:20:38.000Z","updated":"2022-06-25T14:20:38.000Z","comments":true,"path":"2022/06/25/对JS闭包的理解/","permalink":"https://silentwaver.github.io/2022/06/25/%E5%AF%B9JS%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"对JS闭包的理解闭包真的是很抽象，看了好久教程没太看懂。于是搜了一下，发现资料也是很少.但有幸发现一篇解释的很明白的文章。 http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html 闭包的目的是实现函数的私有变量，手段是在函数内部添加另一个函数用于返回结果。 123456789101112131415161718192021function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd&#x3D;function(){n+&#x3D;1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-06-25T14:20:30.000Z","updated":"2022-06-25T14:20:30.000Z","comments":true,"path":"2022/06/25/hello-world/","permalink":"https://silentwaver.github.io/2022/06/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"","slug":"hexo-yilia 博客设置","date":"2022-06-25T14:20:22.000Z","updated":"2022-06-25T14:20:22.000Z","comments":true,"path":"2022/06/25/hexo-yilia 博客设置/","permalink":"https://silentwaver.github.io/2022/06/25/hexo-yilia%20%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE/","excerpt":"hexo-yilia 博客设置！！！！！最基本！！！！！所有对于config的修改都是对&#x2F;theme&#x2F;yilia里的config.yml进行修改，而不是根目录下 其他绝大部分文件也都是在主题文件夹内修改！ 因为这玩意我又改了一天cnm","text":"hexo-yilia 博客设置！！！！！最基本！！！！！所有对于config的修改都是对&#x2F;theme&#x2F;yilia里的config.yml进行修改，而不是根目录下 其他绝大部分文件也都是在主题文件夹内修改！ 因为这玩意我又改了一天cnm ——- 2020.7.15——— 问题：修改config，页面无变化 https://www.jianshu.com/p/77c86971daff 这里对yilia那个配置文件的各模块进行了一些分析，想详细知道的可以看一下。 大部分的修改配置百度全都有，我就不说了，直接搜就有。 文章开头这个问题才是最致命的（或许，大概，应该 在yilia主题文件夹下进行各种配置就没有修改后无变化的问题了（至少我暂时没有 如果你仍有问题，可以通过侧边栏的联系方式联系我，我们一起学⚦习 以后若我有其他发现的问题我也会在此篇进行修改 —–2020.7.16——— https://www.jianshu.com/p/e17711e44e00 hexo 添加分类及标签","categories":[],"tags":[]},{"title":"","slug":"ubuntu sudo apt update 无法解析域名解决办法","date":"2022-06-25T14:20:14.000Z","updated":"2022-06-25T14:20:14.000Z","comments":true,"path":"2022/06/25/ubuntu sudo apt update 无法解析域名解决办法/","permalink":"https://silentwaver.github.io/2022/06/25/ubuntu%20sudo%20apt%20update%20%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"ubuntu sudo apt update 无法解析域名解决办法2020.8.30 最近开学忙，有个点想说给忘了，今天加上去 配置一圈后，虚拟机还是连不上网。 问题很有可能使网络的设置出错了。。。。。其实是很简单的一个点。 进入ubuntu系统后，右上角，网络连接，把有线链接打开。。。 可能就是因为这个点太简单太小了，很多博客里没有提这个事。我也是翻了很多才在一篇文章里找到这个问题。 2020.7.19 网上能搜到的基本是两种方法： ① 添加dns ②更换源 我用的是更换源的办法","text":"ubuntu sudo apt update 无法解析域名解决办法2020.8.30 最近开学忙，有个点想说给忘了，今天加上去 配置一圈后，虚拟机还是连不上网。 问题很有可能使网络的设置出错了。。。。。其实是很简单的一个点。 进入ubuntu系统后，右上角，网络连接，把有线链接打开。。。 可能就是因为这个点太简单太小了，很多博客里没有提这个事。我也是翻了很多才在一篇文章里找到这个问题。 2020.7.19 网上能搜到的基本是两种方法： ① 添加dns ②更换源 我用的是更换源的办法 相信大部分遇到这个问题的读者，此时此刻和我一样是个新手，对命令行的操作方式还不是很熟悉。 比如，通过命令行（ vi sources.list ）打开文件之后不知道怎么修改，也不知道改没改上，也不知道咋返回原界面（＞︿＜ 所以，我不用命令行啦！ 直接打开文件–&gt;其他位置–&gt;计算机–&gt;etc–&gt;apt,就能看到sources.list文件。 在apt文件夹内，右键空白处，选择在终端中打开，然后输入 1sudo chmod 777 sources.list 将该文件修改为所有人都有读写权限，不然该文件默认是只读的，注意此处用到了sudo，所以如果你之前没设置过，你需要设置root账户 可以参考这篇博客：https://blog.csdn.net/ezreal_tao/article/details/86709308 然后右键sources.list文件–&gt;用文本编辑器打开，删除全部内容，将下列内容粘贴进去 12345678910deb http://mirrors.aliyun.com/ubuntu/ vivid main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ vivid-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ vivid-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ vivid-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ vivid-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ vivid-backports main restricted universe multiverse12345678910 然后右上保存 接下来再修改回只读权限 1sudo chmod 644 sources.list 再运行 1sudo apt-get update 然后可能换源后还是无法解析域名（；´д｀）ゞ","categories":[],"tags":[]},{"title":"","slug":"正则表达式记录","date":"2022-06-25T14:20:06.000Z","updated":"2022-06-25T14:20:06.000Z","comments":true,"path":"2022/06/25/正则表达式记录/","permalink":"https://silentwaver.github.io/2022/06/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%B0%E5%BD%95/","excerpt":"正则表达式记录本文档记录一些在平常遇到的正则表达式，积累分析记录,从而提升自己对正则表达式的掌握 正则表达式基本 https://www.runoob.com/regexp/regexp-metachar.html","text":"正则表达式记录本文档记录一些在平常遇到的正则表达式，积累分析记录,从而提升自己对正则表达式的掌握 正则表达式基本 https://www.runoob.com/regexp/regexp-metachar.html 12&#x27;\\d&#123;13,14&#125;&#x27; &#x27;\\|(\\d&#123;5&#125;)\\|&#x27; \\ d {13,14} 表示匹配一个长度为13~14位数字的号码 \\ | (\\d{5}) \\ |,可拆为两部分， 首先为\\ | ,表示匹配 |，然后为（\\d{5}）,表示为匹配一个长度为5位数字的号码，合起来就表示匹配 |xxxxx|，x代表数字。 1&#x27;&lt;a[^&gt;]*&gt;&#x27; [ ^ &gt;],表示一个否定的字符集,匹配除&gt;之外所有字符，*表示匹配前面字符的零次或多次，该正则表达式匹配的字符串为 ““, x表示除 ‘’&gt;’’外的任意字符，x位数不限 很明显，该正则表达式用于匹配html文档中的 标签","categories":[],"tags":[]},{"title":"","slug":"爬虫/爬虫学习","date":"2022-06-25T14:19:58.000Z","updated":"2022-06-25T14:19:58.000Z","comments":true,"path":"2022/06/25/爬虫/爬虫学习/","permalink":"https://silentwaver.github.io/2022/06/25/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/","excerpt":"爬虫学习本文主要参考了https://cuijiahua.com/内的爬虫教程","text":"爬虫学习本文主要参考了https://cuijiahua.com/内的爬虫教程 发起请求：requests，urllib.request库requests库安装 在cmd中，使用如下指令 1pip install requests 或 1easy——install requests 如果遇到请求超时的情况（Read timed out）可使用如下代码 1pip --default-timeout=100 install -U xxx xxx为所要安装的第三方库 或者，多试几次XD 解析数据： BeautifulSoup Beautiful Soup 是 Python 的一个第三方库，主要用于解析网页数据。 123pip install beautifulsoup4# 或者easy_install beautifulsoup4 之后还需要安装 lxml，这是解析 HTML 需要用到的依赖： 1pip install lxml 当然如果请求超时也可以用上面那个代码 反爬虫页面不能右键！ 这就是最最最最低级的反爬虫手段，这个时候我们可以通过键盘的F12调出审查元素窗口。 有的网站甚至把F12都禁掉，这种也是很低级的反爬虫手段，骗骗刚入门的手段而已。 面对这种禁止看页面源码的初级手段，一个优雅的通用解决办法是，在连接前加个view-source:。 referer 反爬虫 Referer可以理解为来路，先打开章节URL链接，再打开图片链接。打开图片的时候，Referer的信息里保存的是章节URL。 动漫之家网站的做法就是，站内的用户访问这个图片，我就给他看，从其它地方过来的用户，我就不给他看。 是不是站内用户，就是根据Referer进行简单的判断。 动态加载问题记录1.正则表达式 参照了菜鸟教程内的正则表达式教程。 https://www.runoob.com/regexp/regexp-example.html 这是在学习中遇到的一个正则表达式 123pics = re.findall(&#x27;\\d&#123;13,14&#125;&#x27;, str(script_info))chapterpic_hou = re.findall(&#x27;\\|(\\d&#123;5&#125;)\\|&#x27;, str(script_info))[0]chapterpic_qian = re.findall(&#x27;\\|(\\d&#123;4&#125;)\\|&#x27;, str(script_info))[0] \\ d {13,14} 表示匹配一个长度为13~14位数字的号码 \\ | (\\d{5}) \\ |,可拆为两部分， 首先为\\ | ,表示匹配 |，然后为（\\d{5}）,表示为匹配一个长度为5位数字的号码，合起来就表示匹配 |xxxxx|，x代表数字。 |(\\d{4})|，同上。 2.一个小问题 在上述段落中，有两个长度为5的数字字符串 |14237|与|41917| 但是在教程的输出结果里，却只匹配到了|14237| 1chapterpic_hou = re.findall(&#x27;\\|(\\d&#123;5&#125;)\\|&#x27;, str(script_info))[0] 愿因原来很简单，是我自己人傻了TAT 因为他在最后面加了个[0],限定只要第一个结果，即|14237| 思考： 如果不确定想要的结果具体在第几位，通过一遍搜索找出对应项？","categories":[],"tags":[]},{"title":"","slug":"win32汇编","date":"2022-06-25T14:19:38.000Z","updated":"2022-06-25T14:19:38.000Z","comments":true,"path":"2022/06/25/win32汇编/","permalink":"https://silentwaver.github.io/2022/06/25/win32%E6%B1%87%E7%BC%96/","excerpt":"","text":"win32汇编1）.386 引用386库。同理，.186，.286 需使引用库与cpu版本对应。 2）.model 内存模式[语言模式] [其他模式]","categories":[],"tags":[]},{"title":"","slug":"TCP 带外数据传输","date":"2022-06-25T14:19:30.000Z","updated":"2022-06-25T14:19:30.000Z","comments":true,"path":"2022/06/25/TCP 带外数据传输/","permalink":"https://silentwaver.github.io/2022/06/25/TCP%20%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/","excerpt":"TCP 带外数据传输2020.1.1 今天复习网络程序设计，里面提到了TCP的带外数据传输是由TCP报文的urg位和紧急指针实现的。但是书上说紧急指针指向的是紧急字段的下一字节。这与我之前复习计算机网络时，书上的描述不符。于是我找了几篇博文看了看，直接给我看蒙了。","text":"TCP 带外数据传输2020.1.1 今天复习网络程序设计，里面提到了TCP的带外数据传输是由TCP报文的urg位和紧急指针实现的。但是书上说紧急指针指向的是紧急字段的下一字节。这与我之前复习计算机网络时，书上的描述不符。于是我找了几篇博文看了看，直接给我看蒙了。 以下是我找到的一种简单易懂的tcp-oob传输的解释。 紧急数据是插在正常数据流中进行传输的 。 一个紧急指针只指向一个字节的带外数据的后一个字节位置。比如我们要发送数据1，2，3，4，5，6 ，7，8，如果我们只发送一个字节的带外数据X，那么发送缓冲区就是（1，2，3，4，5，6，7，8，X），紧急指针置为10，X是带外数据字节 。如果我们发送多个字节的带外数据（X，Y，Z），那么发送缓冲区就是（1，2，3，4，5，6，7，8，X，Y，Z），紧急指针指向Z的后面，为12 ，Z 被当作带外数据字节。 假如由于发送窗口的关系，导致该发送缓冲区中的数据（1，2，3，4，5，6，7，8，X）分为多次或者两次发送。比如：发送窗口是6，那么就分为两个包发送，情况如下：第一个包紧急指针为10，传送六个字节（1,2,3,4,5,6），接收端记下接受的字节数并且发现紧急指针指向的紧急数据没有到达，所以继续等待下一个包，下一个包（紧急指针还是10）发过来 7,8,X ，接收端发现紧急指针指向的紧急数据在这个包里，所以将紧急数据进行处理即可。 我的疑点在于，在《数据通信与网络》这本书里，紧急指针指向紧急数据的末尾，紧急数据置于报文数据段的开始位置。而到了这里，变成了只能传输一字节的紧急数据，且指针指向紧急字节的下一字节，和《网络程序设计》这本书描述符合。 在翻阅更多文章后，我找到了原因。这是由于TCP对紧急数据的处理有两种解释造成的。TCP紧急指针有两种解释， RFC793解释和 BSD解释 。RFC793为最开始的标准。但绝大部分的实现却都基于BSD解释。这其中的原因我暂且蒙在鼓里（ 也就是说，计网里的是RFC793解释，而网络程序设计里则是BSD解释。可能是因为计网偏理论，程序设计偏实践的关系吧。 以下是BSD和RFC的相关信息 BSD (Berkeley Software Distribution，伯克利软件套件)是Unix的衍生系统，在1977至1995年间由加州大学伯克利分校开发和发布的。历史上， BSD曾经被认为是UNIX的一支——“BSD UNIX”, 因为它和AT&amp;T UNIX操作系统共享基础代码和设计。在20世纪80年代，衍生出了许多变形的UNIX授权软件。比较著名的如DEC的Ultrix及Sun公司的SunOS。1990年代，BSD很大程度上被System V4.x版以及OSF&#x2F;1系统所取代，晚期BSD版本为几个开源软件开发提供了平台并且一直沿用至今。今天，“BSD”并不特指任何一个BSD衍生版本，而是类UNIX操作系统中的一个分支的总称。 BSD开源协议是一个给予使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。但”为所欲为”的前提是当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：1.如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。2.如果再发布的只是二进制类库&#x2F;软件，则需要在类库&#x2F;软件的文档和版权声明中包含原来代码中的BSD协议。3.不可以用开源代码的作者&#x2F;机构名字和原来产品的名字做市场推广。 RFC793我没找到具体描述，中文文档全都要钱，呜呜呜，就放个英文的链接吧 RFC793英文原版：https://blog.csdn.net/qq_39661959/article/details/112068434","categories":[],"tags":[]},{"title":"","slug":"用hexo搭建博客","date":"2022-06-25T14:19:22.000Z","updated":"2022-06-25T14:19:22.000Z","comments":true,"path":"2022/06/25/用hexo搭建博客/","permalink":"https://silentwaver.github.io/2022/06/25/%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"用hexo搭建博客2020.7.15 cnm搭了一晚上现在是15日0：07 基本参考资料为 https://www.cnblogs.com/SUNYZBlog/p/10772712.html 还算行 和这篇又配合了一下看的（顺带一提我更推荐这篇，代码比较正确，但图例少，上面那篇有的地方有错误，但是图例丰富 https://www.jianshu.com/p/09875c4a629c 我安装中遇到的问题（详细请展开","text":"用hexo搭建博客2020.7.15 cnm搭了一晚上现在是15日0：07 基本参考资料为 https://www.cnblogs.com/SUNYZBlog/p/10772712.html 还算行 和这篇又配合了一下看的（顺带一提我更推荐这篇，代码比较正确，但图例少，上面那篇有的地方有错误，但是图例丰富 https://www.jianshu.com/p/09875c4a629c 我安装中遇到的问题（详细请展开 各种的 不是内部或外部文件 这种情况是没添加全局变量，搜一下如何添加xxx的全局变量就可以了。 由于我很久之前就装过一次，所以软件都是现成的，安装上的问题不太懂 比如hexo用nmp就是装不上，最后我用现成的凑活了。。。 安装卡住，半天没有下一条显示 多半是网络问题，换源解决。 1npm config set registry https://registry.npm.taobao.org 这是什么淘宝源，我看大部分都说让换成这个。 输入完之后他啥反应没有，直接输下一个指令就行（nmp npm install -g hexo-cli） publisher无法打开 id_rsa.pub、 用记事本打开就行 hexo d失败 ①bash： dev&#x2F;tty no such device or address原因是修改delpoy时，repo那行，不用https，改为ssh ②Permanently added the RSA host key for IP address ‘xxx’ to the list of known hosts.这是个warning，可以忽略。或者把这个ip加到host里 ③Could not read from remote repository说是因为ssh没在github上配置，但我确实配过了，而且前面的测试也成功了。 我尝试用终端运行ssh-keygent，但显示缺少msys-1.0.dll，下载之后按网上的各种方法添加也还是缺失该文件。 然后我尝试其他解决办法，试了一上午，都没用。 最后我决定用git bush里试试，这回成功了，然后我新建了一个ssh，删掉之前的ssh，然后再按步骤走了一遍，问题解决了。 以上基本配置完成。","categories":[],"tags":[]},{"title":"","slug":"kmeans算法实现中一些问题","date":"2022-06-25T14:19:12.000Z","updated":"2022-06-25T14:19:12.000Z","comments":true,"path":"2022/06/25/kmeans算法实现中一些问题/","permalink":"https://silentwaver.github.io/2022/06/25/kmeans%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","excerpt":"kmeans算法实现中一些问题2020.11.22 本来，是没打算写一篇文的 然后发现自己写的代码计算出的平均准确度是错误的 然后我就疯了","text":"kmeans算法实现中一些问题2020.11.22 本来，是没打算写一篇文的 然后发现自己写的代码计算出的平均准确度是错误的 然后我就疯了 我本计划通过比较保留数据集自带的标签与划分后的标签来判断精度，但是程序划分出的标签完全乱套了，无法确定哪个簇是哪个簇。 硬改应该也能改出来，但只能适用于单个数据集，如何改成具有泛用性的代码，莫得头绪。以下是我的源码，没什么必要看，我也放上了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105 # coding=utf-8from numpy import *import timeimport xlwtfrom xlrd import open_workbookfrom xlutils.copy import copyimport mathlistA = [] def distE(vecA,vecB): return sqrt(sum(power(vecA-vecB,2)))def loadData(filename,n): dataMat = [] fr = open(filename) for line in fr.readlines(): curLine = line.strip(&#x27;\\n&#x27;).split(&#x27;,&#x27;) temp=curLine[0] del curLine[0] listA.append(temp) #listA.append(curLine) fltLine = list(map(float,curLine)) dataMat.append(fltLine) return dataMatdef randCent(dataSet, k): n = shape(dataSet)[1] centroids = mat(zeros((k,n))) for j in range(n): minJ = min(dataSet[:,j]) maxJ = max(dataSet[:,j]) rangeJ = float(maxJ - minJ) centroids[:,j] = minJ + rangeJ * random.rand(k, 1) return centroidsdef kMeans(dataSet, k, distMeans =distE, createCent = randCent): m = shape(dataSet)[0] clusterAssment = mat(zeros((m,2))) centroids = createCent(dataSet, k) clusterChanged = True while clusterChanged: clusterChanged = False; for i in range(m): minDist = inf; minIndex = -1; for j in range(k): distJI = distMeans(centroids[j,:], dataSet[i,:]) if distJI &lt; minDist: minDist = distJI; minIndex = j if clusterAssment[i,0] != minIndex: clusterChanged = True; clusterAssment[i,:] = minIndex,minDist**2 #print(centroids) for cent in range(k): ptsInClust = dataSet[nonzero(clusterAssment[:,0].A == cent)[0]] centroids[cent,:] = mean(ptsInClust, axis = 0) return centroids, clusterAssment def accCalu(clus): global listA mable=[] acc = 0 n=0 total = len(listA) listA=list(map(int,listA)) for i in clus: if isinstance(i, list): mable.append(int(i[0])+1) for j in mable: if j == listA[n]: acc=acc+1 n=n+1 #print(&#x27;准确度: &#123;:.2f&#125;%&#x27;.format((acc/total)*100)) print(mable) print(clus) return (acc/total)*100 datMat = mat(loadData(&#x27;Ecoli.txt&#x27;,8))cnt_times=1TStime = time.time()TaccA = 0 while (1): starttime = time.time() myCentroids,clustAssing = kMeans(datMat,8) endtime = time.time() dtime = endtime - starttime accA = accCalu(clustAssing.tolist()) listR=[] listR.append([accA,dtime]) TaccA += accA cnt_times+=1 if(cnt_times&gt;1): break TEtime = time.time()TDtime = TEtime - TStimeprint(&#x27;平均准确度: &#123;:.2f&#125;%&#x27; .format(TaccA/100))print(&quot;总训练时间：%.8s s&quot; % TDtime)","categories":[],"tags":[]},{"title":"","slug":"html/htmlcssjs 问题记录","date":"2022-06-25T14:18:56.000Z","updated":"2022-06-25T14:18:56.000Z","comments":true,"path":"2022/06/25/html/htmlcssjs 问题记录/","permalink":"https://silentwaver.github.io/2022/06/25/html/htmlcssjs%20%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"html&#x2F;css&#x2F;js 问题记录本文章用于记录学html&#x2F;css&#x2F;js中遇到的一些问题 因为这几者联系比较紧密，分不清哪个是哪个方面的问题，故一起记录","text":"html&#x2F;css&#x2F;js 问题记录本文章用于记录学html&#x2F;css&#x2F;js中遇到的一些问题 因为这几者联系比较紧密，分不清哪个是哪个方面的问题，故一起记录 2020.8.27 摁键输入1234var keychar=String.fromCharCode(x);if (keychar==&quot;A&quot;)&#123;alert(&quot;按键 &quot; + keychar + &quot; 被按下&quot;);&#125;&#125; 我本来是想 keychar&#x3D;&#x3D;”a”时使响应，但是始终没有反应。怀着试一试的心情，改成了A，结果成功，但a也可以对其产生响应。 2020 8.29 自调用函数 闭包123456var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)();function myFunction()&#123; document.getElementById(&quot;demo&quot;).innerHTML = add(); 为什么每次执行时 counter变量不会重置为0 12345678function add() &#123; var counter = 0; return counter += 1;&#125; add();add();add(); 与上面这个有什么区别？ 参考了一下这篇文章：https://www.cnblogs.com/data-captain/p/9861274.html 大概就是，add函数通过自调用的形式形成了一个闭包，使counter变量只在此对象中使用。 闭包：通俗讲就是函数中的函数 在js中，函数也是一个对象。对象中的函数，在作用域里讲过， 通过function functionName(){}的方式定义的是私有成员函数，只能给对象内部使用； 也就是说，在 1234var add = (function () &#123; var counter = 0; return function () &#123;return counter += 1;&#125;&#125;)(); 第二个function，即是一个闭包。他相当于从外层那里获得了counter初值，再自己初始化了一个counter变量，供自己使用。内部的counter只是与外部的同名，完全相当于一个新变量，作用域为第二个function内。该函数的结构使最终return值为第二个function的返回值。 而第二种代码，由于是通过函数名调用，每一次调用都会使counter被重新初始化为0，再进行+1。 对猜想进行验证 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;计数器测试二&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;局部变量计数。&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;计数!&lt;/button&gt;&lt;button type=&quot;button&quot; onclick=&quot;mF()&quot;&gt;计数2!&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;0&lt;/p&gt;&lt;p id=&quot;dm&quot;&gt;0&lt;/p&gt;&lt;script&gt; function add() &#123; var counter = 2; return function () &#123;return counter += 1;&#125;&#125;;//创建闭包函数var addd = new add();//分别进行两个初始化，分配到不同触发器上，检验是否独立变量var ad = new add();function myFunction()&#123; document.getElementById(&quot;demo&quot;).innerHTML = ad();&#125;function mF()&#123; document.getElementById(&quot;dm&quot;).innerHTML=addd();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在摁两个摁键时，两个计数器分别计数。说明他们没有共享变量。同时他们初始值都为2，说明他们一开始都从外层counter继承了初始值。","categories":[],"tags":[]},{"title":"","slug":"html/html学习（1）","date":"2022-06-25T14:18:48.000Z","updated":"2022-06-25T14:18:48.000Z","comments":true,"path":"2022/06/25/html/html学习（1）/","permalink":"https://silentwaver.github.io/2022/06/25/html/html%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/","excerpt":"html学习（1）2020.7.14使用软件：vs code html 基础","text":"html学习（1）2020.7.14使用软件：vs code html 基础 第一个html文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;???&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; title 用于决定在标签页显示的名字 标题标题由 h1~h6 标签决定 123&lt;h1&gt;这是一个标题&lt;/h1&gt;&lt;h2&gt;这是一个标题&lt;/h2&gt;&lt;h3&gt;这是一个标题&lt;/h3&gt; 段落12&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;p&gt;这是另外一个段落。&lt;/p&gt; 超链接1&lt;a href=&quot;https://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt; href 后接目标链接地址，标签a内为超链接上显示内容 图像1&lt;img src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt; 1、***.html** 文件跟 ***.jpg** 文件(f盘)在不同目录下： 1&lt;img src=&quot;file:///f:/*.jpg&quot; width=&quot;300&quot; height=&quot;120&quot;/&gt; 2、***.html** 文件跟 ***.jpg** 图片在相同目录下： 1&lt;img src=&quot;*.jpg&quot; width=&quot;300&quot; height=&quot;120&quot;/&gt; 3、***.html*****.jpg** a、图片 .jpg 在 image 文件夹中，.html 跟 image 在同一目录下： 1&lt;img src=&quot;image/*.jpg/&quot;width=&quot;300&quot; height=&quot;120&quot;/&gt; b、图片 .jpg 在 image 文件夹中，.html 在 connage 文件夹中，image 跟 connage 在同一目录下： 1&lt;img src=&quot;../image/*.jpg/&quot;width=&quot;300&quot; height=&quot;120&quot;/&gt; 4、如果图片来源于网络，那么写绝对路径： 1&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;300&quot; height=&quot;120&quot;/&gt;","categories":[],"tags":[]},{"title":"","slug":"线程的实现","date":"2022-06-25T14:18:06.000Z","updated":"2022-06-25T14:18:06.000Z","comments":true,"path":"2022/06/25/线程的实现/","permalink":"https://silentwaver.github.io/2022/06/25/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"线程的实现2020.8.7 https://blog.csdn.net/vbirdbest/article/details/81282163","categories":[],"tags":[]},{"title":"","slug":"内网穿透后续","date":"2022-06-25T14:17:58.000Z","updated":"2022-06-25T14:17:58.000Z","comments":true,"path":"2022/06/25/内网穿透后续/","permalink":"https://silentwaver.github.io/2022/06/25/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%90%8E%E7%BB%AD/","excerpt":"内网穿透后续2021.3.16 今早搞了个阿里云的学生云主机，白嫖两个月，于是打算接着试试内网穿透。用了frp。基本配置方法很多博客都有写，在此不再重复，主要记录下我配置时遇到的问题。","text":"内网穿透后续2021.3.16 今早搞了个阿里云的学生云主机，白嫖两个月，于是打算接着试试内网穿透。用了frp。基本配置方法很多博客都有写，在此不再重复，主要记录下我配置时遇到的问题。 1.配置服务端时，bashboard无法正常打开。 大概原因是我把整个frp文件夹丢到了&#x2F;root文件夹下，而且frps.services 文件中的 ExecStart 项没配置对。后来把整个文件夹扔到了&#x2F;opt里，并改 1execstart=frps所在文件夹 -c 所在文件夹frps.ini 这俩文件就在同一个文件夹里。记得别把frp扔到~里,（我也不知道为啥，我猜是root文件夹权限高难以被读取）","categories":[],"tags":[]},{"title":"","slug":"对OSI模型的理解","date":"2022-06-25T14:17:50.000Z","updated":"2022-06-25T14:17:50.000Z","comments":true,"path":"2022/06/25/对OSI模型的理解/","permalink":"https://silentwaver.github.io/2022/06/25/%E5%AF%B9OSI%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"对OSI模型的理解2020.12.26 ​ OSI模型各层功能的正式定义说实话，说的就不是个人话。学完之后还是有点懵。就如网络层之间能不能直接进行通信？书上的概念给的挺暧昧的，感觉好像能。在翻了很多解释后，也终于对osi模型有了更深刻的认知。 ​ 书上是自底向上介绍的，但我个人觉得自顶向下更容易理解。所以我这里从上往下介绍并给出比喻，可能有些不准确。参考了另一位的文章，将其比喻为一个公司收发快递的过程，并对我认为其描述不完善的地方做了一些补充和更改。","text":"对OSI模型的理解2020.12.26 ​ OSI模型各层功能的正式定义说实话，说的就不是个人话。学完之后还是有点懵。就如网络层之间能不能直接进行通信？书上的概念给的挺暧昧的，感觉好像能。在翻了很多解释后，也终于对osi模型有了更深刻的认知。 ​ 书上是自底向上介绍的，但我个人觉得自顶向下更容易理解。所以我这里从上往下介绍并给出比喻，可能有些不准确。参考了另一位的文章，将其比喻为一个公司收发快递的过程，并对我认为其描述不完善的地方做了一些补充和更改。 &lt;1&gt; 应用层 ​ OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。 ​ 实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。 &lt;2&gt; 表示层 ​ 表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。 ​ 由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。 &lt;3&gt; 会话层 ​ 会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 会话层的同事拿到表示层的同事转换后资料，会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。 &lt;4&gt; 传输层 ​ 传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。 ​ 传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。 &lt;5&gt; 网络层 ​ 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。 网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递，首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。 &lt;6&gt; 数据链路层 ​ 将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 ​ 数据链路层就先当于把散件打包，集装到运输工具上。 &lt;7&gt; 物理层 ​ 实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。 ​ 快递寄送过程中的走的路，就相当于我们的物理层，例如汽车走的公路，火车走铁轨，飞机走航线。物理层还包含了开车、开飞机这一含义。比如无线通信就相当于用飞机传输，传输过程就相当于把飞机开到目的地；用线缆传输相当于用汽车运 个人对osi的一些理解1.回答开头的问题，网络层之间不能直接通信。网络端只会在数据头部封装源地址和目的地址，并为数据包的传送选择路径（即选择经过哪几个路由器）。做完这些工作他就会把这些东西做成一个SDU传给链路层，链路层再操作后传给物理层，物理层再进行真正的数据传输。即使是无线通信，其收发设备和传输介质（空间（空气）即是其传输介质）也归属于物理层。数据链路层同理。 2.上文红字只是比喻，与OSI的差距还是很大的。就比如，我们比喻数字链路层是将散件打包到运输车，然后物理层相当于车和开车。但实际物理层的传输方式并不是“开车”，而是把物品打碎成分子，运到另一端，再重新组合成原样。即，按位（bit）传输。 本身一个货物（数据）可能有10kg（假定等于100bit），到达数据链路层后，和其他货物一起打包装车，装了123kg（一个帧，总共1234bit），然后还原成分子（1bit），通过信道1bit1bit的送。在接收端，再把数据1bit1bit在数据链路层还原成一个帧，再向上传输。不断拆解头部，最后数据到达目的进程（应用层）。 3.没了，再想起来在补充￣▽￣ 也可能永远没了（","categories":[],"tags":[]},{"title":"","slug":"记一次内网穿透","date":"2022-06-25T14:17:40.000Z","updated":"2022-06-25T14:17:40.000Z","comments":true,"path":"2022/06/25/记一次内网穿透/","permalink":"https://silentwaver.github.io/2022/06/25/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","excerpt":"记一次内网穿透昨天中午买的小型主机到了，打算搭个个人网盘顺带当个服务器啥的。当我终于把网盘配置好并兴高采烈的把网盘地址分享给我的lsp群友时，他们跟我说：连不到网盘。 我说，啪的一下，很快啊，我就想起来我这网相当于一个局域网，外网应该是连不进来的。我说婷婷，我去搞个内网穿透试试。 然后昨晚就各种搜教程搞了一晚上。没整成。今天上午上完课回来就接着开干。当然还是没整成。但是我也算是搞懂了失败的原因，并找到了一个可行的解决方式，有钱了一定试o(╥﹏╥)o","text":"记一次内网穿透昨天中午买的小型主机到了，打算搭个个人网盘顺带当个服务器啥的。当我终于把网盘配置好并兴高采烈的把网盘地址分享给我的lsp群友时，他们跟我说：连不到网盘。 我说，啪的一下，很快啊，我就想起来我这网相当于一个局域网，外网应该是连不进来的。我说婷婷，我去搞个内网穿透试试。 然后昨晚就各种搜教程搞了一晚上。没整成。今天上午上完课回来就接着开干。当然还是没整成。但是我也算是搞懂了失败的原因，并找到了一个可行的解决方式，有钱了一定试o(╥﹏╥)o 内网穿透大概有两种形式 1.端口映射 需要路由器有公网ip，通过将公网ip+duankou与内网ip+端口绑定，使发到公网ip的数据被转发到目的内网端口。 2.反向代理 找个有公网ip的机器，反向代理，使送到有外网主机的数据被送到内网主机。 我一开始找的方法是用frp实现反向代理，失败原因就是没有有外网ip的主机。部署完了才发现没服务端。也试了其他一些类似的程序，差不多的失败。 然后我尝试用nat123设置端口映射，也不行。用路由器自带的端口转发，也是不行。最后意识到是因为我们这校园网分配给路由器的ip还是个内网ip，我也没办法进学校的机房搞 只能放弃这条路。 然后那就只能尝试方法2，所以就需要搞个云服务器，没钱钱，买不起，下次一定（","categories":[],"tags":[]},{"title":"","slug":"pip 换源","date":"2022-06-25T14:17:32.000Z","updated":"2022-06-25T14:17:32.000Z","comments":true,"path":"2022/06/25/pip 换源/","permalink":"https://silentwaver.github.io/2022/06/25/pip%20%E6%8D%A2%E6%BA%90/","excerpt":"","text":"pip 换源2020.9.23 解决pip安装时各种readtimeout问题 即刻芜湖起飞 新建py文件(文件名随意)，复制以下代码 1234567891011121314import os ini=&quot;&quot;&quot;[global]index-url = https://pypi.doubanio.com/simple/[install]trusted-host=pypi.doubanio.com&quot;&quot;&quot;pippath=os.environ[&quot;USERPROFILE&quot;]+&quot;\\\\pip\\\\&quot; if not os.path.exists(pippath): os.mkdir(pippath) with open(pippath+&quot;pip.ini&quot;,&quot;w+&quot;) as f: f.write(ini) 之后在命令行运行，即可成功。","categories":[],"tags":[]}],"categories":[],"tags":[]}